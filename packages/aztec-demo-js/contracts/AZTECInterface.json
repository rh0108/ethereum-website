{
  "contractName": "AZTECInterface",
  "abi": [
    {
      "constant": true,
      "inputs": [
        {
          "name": "",
          "type": "bytes32[6][]"
        },
        {
          "name": "",
          "type": "uint256"
        },
        {
          "name": "",
          "type": "uint256"
        },
        {
          "name": "",
          "type": "bytes32[4]"
        }
      ],
      "name": "validateJoinSplit",
      "outputs": [
        {
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "bytecode": "0x60bf61002f600b82828239805160001a6073146000811461001f57610021565bfe5b5030600052607381538281f300730000000000000000000000000000000000000000301460806040526004361060555763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663b5596a888114605a575b600080fd5b607460246004803582810192910135903560443560646088565b604080519115158252519081900360200190f35b6000959450505050505600a165627a7a72305820a161a4f017fb00d97c99c535222f08cc92d49fdab68a675fb90441e3c00fa6470029",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361060555763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663b5596a888114605a575b600080fd5b607460246004803582810192910135903560443560646088565b604080519115158252519081900360200190f35b6000959450505050505600a165627a7a72305820a161a4f017fb00d97c99c535222f08cc92d49fdab68a675fb90441e3c00fa6470029",
  "sourceMap": "26:127:0:-;;132:2:-1;166:7;155:9;146:7;137:37;252:7;246:14;243:1;238:23;232:4;229:33;270:1;265:20;;;;222:63;;265:20;274:9;222:63;;298:9;295:1;288:20;328:4;319:7;311:22;352:7;343;336:24",
  "deployedSourceMap": "26:127:0:-;;;;;;;;;;;;;;;;;;;;;;;;;;55:96;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;143:4;55:96;;;;;;;:::o",
  "source": "pragma solidity ^0.4.24;\n\nlibrary AZTECInterface {\n    function validateJoinSplit(bytes32[6][], uint, uint, bytes32[4]) external pure returns (bool) {}\n}\n\n/**\n * @title Library to validate AZTEC zero-knowledge proofs\n * @author Zachary Williamson, AZTEC\n * @dev Don't include this as an internal library. This contract uses a static memory table to cache elliptic curve primitives and hashes.\n * Calling this internally from another function will lead to memory mutation and undefined behaviour.\n * The intended use case is to call this externally via `staticcall`. External calls to OptimizedAZTEC can be treated as pure functions as this contract contains no storage and makes no external calls (other than to precompiles)\n * Copyright Spilbury Holdings Ltd 2018. All rights reserved.\n * We will be releasing AZTEC as an open-source protocol that provides efficient transaction privacy for Ethereum.\n * Our full vision of the protocol includes confidential cross-asset interactions via our family of AZTEC zero-knowledge proofs\n * and the AZTEC token standard, stay tuned for updates!\n **/\ncontract AZTEC {\n    /**\n     * @dev AZTEC will take any transaction sent to it and attempt to validate a zero knowledge proof.\n     * If the proof is not valid, the transaction will throw.\n     * @notice See AZTECInterface for how method calls should be constructed.\n     * 'Cost' of raw elliptic curve primitives for a transaction: 260,700 gas + (124,500 * number of input notes) + (167,600 * number of output notes).\n     * For a basic 'joinSplit' with 2 inputs and 2 outputs = 844,900 gas.\n     * AZTEC is written in YUL to enable manual memory management and for other efficiency savings.\n     **/\n    function() external payable {\n        assembly {\n\n            // We don't check for function signatures, there's only one function that ever gets called: validateJoinSplit()\n            // We still assume calldata is offset by 4 bytes so that we can represent this contract through a compatible ABI\n            validateJoinSplit()\n\n            // should not get here\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n\n            /**\n             * @dev Validate an AZTEC protocol JoinSplit zero-knowledge proof\n             * Calldata Map is\n             * 0x04:0x24       = calldata location of start of ```note``` dynamic array\n             * 0x24:0x44       = m, which defines the index separator between input notes ando utput notes\n             * 0x44:0x64       = Fiat-Shamir heuristicified random challenge\n             * 0x64:0xe4       = G2 element t2, the trusted setup public key\n             * 0xe4:0x104      = start of ```note``` dynamic array, contains the size of the array (```n```)\n             * Subsequent calldata arranged in 0xc0 sized blocks of data, each representing an AZTEC commitment and zero-knowledge proof variables\n             *\n             * Note data map (uint[6]) is\n             * 0x00:0x20       = Z_p element \\bar{k}_i\n             * 0x20:0x40       = Z_p element \\bar{a}_i\n             * 0x40:0x80       = G1 element \\gamma_i\n             * 0x80:0xc0       = G1 element \\sigma_i\n             *\n             * The last element in the note array is special and contains the following:\n             * 0x00:0x20       = Z_p element k_{public}\n             * 0x20:0x40       = Z_p element \\bar{a}_i\n             * 0x40:0x60       = G1 element \\gamma_i\n             * 0x60-0x80       = G1 element \\sigma_i\n             * We can recover \\bar{k}_{n-1} from the homomorphic sum condition \\sum_{i=0}^{m-1}\\bar{k}_i = \\sum_{i=m}^{n-1}\\bar{k}_i + k_{public}\n             * So we use the empty slot to store k_{public}, which represents any public 'value' being blinded into zero-knowledge notes\n             *\n             * We use a hard-coded memory map to reduce gas costs - if this is not called as an external contract then terrible things will happen!\n             * 0x00:0x20       = scratch data to store result of keccak256 calls\n             * 0x20:0x80       = scratch data to store \\gamma_i and a multiplication scalar\n             * 0x80:0xc0       = x-coordinate of generator h\n             * 0xc0:0xe0       = y-coordinate of generator h\n             * 0xe0:0x100      = scratch data to store a scalar we plan to multiply h by\n             * 0x100:0x160     = scratch data to store \\sigma_i and a multiplication scalar\n             * 0x160:0x1a0     = stratch data to store result of G1 point additions\n             * 0x1a0:0x1c0     = scratch data to store result of \\sigma_i^{-cx_{i-m-1}}\n             * 0x1c0:0x200     = location of pairing accumulator \\sigma_{acc}, where \\sigma_{acc} = \\prod_{i=m}^{n-1}\\sigma_i^{cx_{i-m-1}}\n             * 0x220:0x260     = scratch data to store \\gamma_i^{cx_{i-m-1}}\n             * 0x260:0x2a0     = location of pairing accumulator \\gamma_{acc}, where \\gamma_{acc} = \\prod_{i=m}^{n-1}\\gamma_i^{cx_{i-m-1}}\n             * 0x2a0:0x2c0     = msg.sender (contract should be called via delegatecall/staticcall)\n             * 0x2c0:0x2e0     = kn (memory used to reconstruct hash starts here)\n             * 0x2e0:0x300     = m\n             * 0x300:???       = block of memory that contains (\\gamma_i, \\sigma_i)_{i=0}^{n-1} concatenated with (B_i)_{i=0}^{n-1}\n             **/\n            function validateJoinSplit() {\n                mstore(0x80, 7673901602397024137095011250362199966051872585513276903826533215767972925880) // h_x\n                mstore(0xa0, 8489654445897228341090914135473290831551238522473825886865492707826370766375) // h_y\n                let notes := add(0x04, calldataload(0x04))\n                let m := calldataload(0x24)\n                let n := calldataload(notes)\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n                let challenge := mod(calldataload(0x44), gen_order)\n\n                // validate m <= n\n                if gt(m, n) { mstore(0x00, 404) revert(0x00, 0x20) }\n\n                // recover k_{public} and calculate k_{public}\n                let kn := calldataload(sub(calldatasize, 0xc0))\n\n                // add kn and m to final hash table\n                mstore(0x2a0, caller)\n                mstore(0x2c0, kn)\n                mstore(0x2e0, m)\n                kn := mulmod(sub(gen_order, kn), challenge, gen_order) // we actually want c*k_{public}\n                hashCommitments(notes, n)\n                let b := add(0x300, mul(n, 0x80))\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n                // We use the AZTEC protocol pairing optimization to reduce the number of pairing comparisons to 1, which adds some minor alterations\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n                    // Get the calldata index of this note\n                    let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                    // Define variables k, a and c.\n                    // If i <= m then\n                    //   k = kBar_i\n                    //   a = aBar_i\n                    //   c = challenge\n                    // If i > m then we add a modification for the pairing optimization\n                    //   k = kBar_i * x_i\n                    //   a = aBar_i * x_i\n                    //   c = challenge * x_i\n                    // Set j = i - (m + 1).\n                    // x_0 = 1\n                    // x_1 = keccak256(input string)\n                    // all other x_{j} = keccak256(x_{j-1})\n                    // The reason for doing this is that the point  \\sigma_i^{-cx_j} can be re-used in the pairing check\n                    // Instead of validating e(\\gamma_i, t_2) == e(\\sigma_i, g_2) for all i = [m+1,\\ldots,n]\n                    // We instead validate e(\\Pi_{i=m+1}^{n}\\gamma_i^{-cx_j}, t_2) == e(\\Pi_{i=m+1}^{n}\\sigma_i^{cx_j}, g_2).\n                    // x_j is a pseudorandom variable whose entropy source is the input string, allowing for\n                    // a sum of commitment points to be evaluated in one pairing comparison\n                    let k\n                    let a := calldataload(add(noteIndex, 0x20))\n                    let c := challenge\n\n                    // We don't transmit kBar_{n-1} in the proof to save space, instead we derive it\n                    // As per the homomorphic sum condition: \\sum_{i=0}^{m-1}\\bar{k}_i = \\sum_{i=m}^{n-1}\\bar{k}_i + k_{public}c, \n                    // We can recover \\bar{k}_{n-1}.\n                    // If m=n then \\bar{k}_{n-1} = \\sum_{i=0}^{n-1}\\bar{k}_i + k_{public}\n                    // else \\bar{k}_{n-1} = \\sum_{i=0}^{m-1}\\bar{k}_i - \\sum_{i=m}^{n-1}\\bar{k}_i - k_{public}\n                    switch eq(add(i, 0x01), n)\n                    case 1 {\n                        k := kn\n\n                        // if all notes are input notes, invert k\n                        if eq(m, n) {\n                            k := sub(gen_order, k)\n                        }\n                    }\n                    case 0 { k := calldataload(noteIndex) }\n\n                    // Check this commitment is well formed...\n                    validateCommitment(noteIndex, k, a)\n\n                    // If i > m then this is an output note.\n                    // Set k = kx_j, a = ax_j, c = cx_j, where j = i - (m+1)\n                    switch gt(add(i, 0x01), m)\n                    case 1 {\n\n                        // before we update k, update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n                        kn := addmod(kn, sub(gen_order, k), gen_order)\n                        let x := mod(mload(0x00), gen_order)\n                        k := mulmod(k, x, gen_order)\n                        a := mulmod(a, x, gen_order)\n                        c := mulmod(challenge, x, gen_order)\n\n                        // calculate x_{j+1}\n                        mstore(0x00, keccak256(0x00, 0x20))\n                    }\n                    case 0 {\n\n                        // nothing to do here except update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n                        kn := addmod(kn, k, gen_order)\n                    }\n                    \n                    // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\n                    // Memory map:\n                    // 0x20: \\gamma_iX\n                    // 0x40: \\gamma_iY\n                    // 0x60: k_i\n                    // 0x80: hX\n                    // 0xa0: hY\n                    // 0xc0: a_i\n                    // 0xe0: \\sigma_iX\n                    // 0x100: \\sigma_iY\n                    // 0x120: -c\n                    calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n                    calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n                    mstore(0x120, sub(gen_order, c)) \n                    mstore(0x60, k)\n                    mstore(0xc0, a)\n\n                    // Call bn128 scalar multiplication precompiles\n                    // Represent point + multiplication scalar in 3 consecutive blocks of memory\n                    // Store \\sigma_i^{-c} at 0x1a0:0x200\n                    // Store \\gamma_i^{k} at 0x120:0x160\n                    // Store h^{a} at 0x160:0x1a0\n                    let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40)\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\n                    result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\n\n                    // Call bn128 group addition precompiles\n                    // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n                    // Store result of addition at 0x160:0x1a0\n                    result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n                    // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n                    // Store resulting point B at memory index b\n                    result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n                    // We have \\sigma^{-c} at 0x1a0:0x200\n                    // And \\sigma_{acc} at 0x1e0:0x200\n                    // If i = m + 1 (i.e. first output note)\n                    // then we set \\gamma_{acc} and \\sigma_{acc} to \\gamma_i, -\\sigma_i\n                    if eq(i, m) {\n                        mstore(0x260, mload(0x20))\n                        mstore(0x280, mload(0x40))\n                        mstore(0x1e0, mload(0xe0))\n                        mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n                    }\n\n                    // If i > m + 1 (i.e. subsequent output notes)\n                    // then we add \\sigma^{-c} and \\sigma_{acc} and store result at \\sigma_{acc} (0x1e0:0x200)\n                    // we then calculate \\gamma^{cx} and add into \\gamma_{acc}\n                    if gt(i, m) {\n                       mstore(0x60, c)\n                       result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40))\n\n                       // \\gamma_i^{cx} now at 0x220:0x260, \\gamma_{acc} is at 0x260:0x2a0\n                       result := and(result, staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40))\n\n                       // add \\sigma_i^{-cx} and \\sigma_{acc} into \\sigma_{acc} at 0x1e0\n                       result := and(result, staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40))\n                    }\n\n                    // throw transaction if any calls to precompiled contracts failed\n                    if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n                    b := add(b, 0x40) // increase B pointer by 2 words\n                }\n\n                // If the AZTEC protocol is implemented correctly then any input notes were previously outputs of\n                // a JoinSplit transaction. We can inductively assume that all input notes are well-formed AZTEC commitments and do not need to validate the implicit range proof\n                // This is not the case for any output commitments, so if (m < n) call validatePairing()\n                if lt(m, n) {\n                   validatePairing(0x64)\n                }\n\n                // We now have the note commitments and the calculated blinding factors in a block of memory\n                // starting at 0x2a0, of size (b - 0x2a0).\n                // Hash this block to reconstruct the initial challenge and validate that they match\n                let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n                if iszero(eq(expected, challenge)) {\n\n                    // No! Bad! No soup for you!\n                    mstore(0x00, 404)\n                    revert(0x00, 0x20)\n                }\n\n                // Great! All done. This is a valid proof so return ```true```\n                mstore(0x00, 0x01)\n                return(0x00, 0x20)\n            }\n\n            /**        \n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\n             * @notice we don't hard-code t2 so that contracts that call this library can use different trusted setups.\n             **/\n            function validatePairing(t2) {\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n                let t2_x_1 := calldataload(t2)\n                let t2_x_2 := calldataload(add(t2, 0x20))\n                let t2_y_1 := calldataload(add(t2, 0x40))\n                let t2_y_2 := calldataload(add(t2, 0x60))\n\n                // check provided setup pubkey is not zero or g2\n                if or(or(or(or(or(or(or(\n                    iszero(t2_x_1),\n                    iszero(t2_x_2)),\n                    iszero(t2_y_1)),\n                    iszero(t2_y_2)),\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n                {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n\n                // store coords in memory\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite to what precompile expects\n                // We can overwrite the memory we used previously as this function is called at the end of the validation routine.\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\n                mstore(0x40, mload(0x200)) // sigma accumulator y\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\n                mstore(0x100, mload(0x280)) // gamma accumulator y\n                mstore(0x140, t2_x_1)\n                mstore(0x120, t2_x_2)\n                mstore(0x180, t2_y_1)\n                mstore(0x160, t2_y_2)\n\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\n\n                if or(iszero(success), iszero(mload(0x20))) {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n             * and that signatures 'k' and 'a' are modulo the order of the curve. Transaction will throw if this is not the case.\n             * @param note the calldata loation of the note\n             **/\n            function validateCommitment(note, k, a) {\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n                let gammaX := calldataload(add(note, 0x40))\n                let gammaY := calldataload(add(note, 0x60))\n                let sigmaX := calldataload(add(note, 0x80))\n                let sigmaY := calldataload(add(note, 0xa0))\n                if iszero(\n                    and(\n                        and(\n                            and(\n                                eq(mod(a, gen_order), a), // a is modulo generator order?\n                                gt(a, 1)                  // can't be 0 or 1 either!\n                            ),\n                            and(\n                                eq(mod(k, gen_order), k), // k is modulo generator order?\n                                gt(k, 1)                  // and not 0 or 1\n                            )\n                        ),\n                        and(\n                            eq( // y^2 ?= x^3 + 3\n                                addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order),\n                                mulmod(sigmaY, sigmaY, field_order)\n                            ),\n                            eq( // y^2 ?= x^3 + 3\n                                addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order),\n                                mulmod(gammaY, gammaY, field_order)\n                            )\n                        )\n                    )\n                ) {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**\n             * @dev Calculate the keccak256 hash of the commitments for both input notes and output notes.\n             * This is used both as an input to validate the challenge `c` and also to generate pseudorandom relationships\n             * between commitments for different outputNotes, so that we can combine them into a single multi-exponentiation for the purposes of validating the bilinear pairing relationships.\n             * @param notes calldata location notes\n             * @param n number of notes\n             **/\n            function hashCommitments(notes, n) {\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n                    let index := add(add(notes, mul(i, 0xc0)), 0x60)\n                    calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n                }\n                mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n            }\n        }\n    }\n}",
  "sourcePath": "/Users/paulrberg/Documents/Work/AZTEC/Coding/AZTEC/contracts/AZTEC/AZTEC.sol",
  "ast": {
    "absolutePath": "/Users/paulrberg/Documents/Work/AZTEC/Coding/AZTEC/contracts/AZTEC/AZTEC.sol",
    "exportedSymbols": {
      "AZTEC": [
        27
      ],
      "AZTECInterface": [
        21
      ]
    },
    "id": 28,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 1,
        "literals": [
          "solidity",
          "^",
          "0.4",
          ".24"
        ],
        "nodeType": "PragmaDirective",
        "src": "0:24:0"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "library",
        "documentation": null,
        "fullyImplemented": true,
        "id": 21,
        "linearizedBaseContracts": [
          21
        ],
        "name": "AZTECInterface",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 19,
              "nodeType": "Block",
              "src": "149:2:0",
              "statements": []
            },
            "documentation": null,
            "id": 20,
            "implemented": true,
            "isConstructor": false,
            "isDeclaredConst": true,
            "modifiers": [],
            "name": "validateJoinSplit",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 15,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 6,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 20,
                  "src": "82:12:0",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_array$_t_bytes32_$6_calldata_$dyn_calldata_ptr",
                    "typeString": "bytes32[6][]"
                  },
                  "typeName": {
                    "baseType": {
                      "baseType": {
                        "id": 2,
                        "name": "bytes32",
                        "nodeType": "ElementaryTypeName",
                        "src": "82:7:0",
                        "typeDescriptions": {
                          "typeIdentifier": "t_bytes32",
                          "typeString": "bytes32"
                        }
                      },
                      "id": 4,
                      "length": {
                        "argumentTypes": null,
                        "hexValue": "36",
                        "id": 3,
                        "isConstant": false,
                        "isLValue": false,
                        "isPure": false,
                        "kind": "number",
                        "lValueRequested": false,
                        "nodeType": "Literal",
                        "src": "90:1:0",
                        "subdenomination": null,
                        "typeDescriptions": {
                          "typeIdentifier": null,
                          "typeString": null
                        },
                        "value": "6"
                      },
                      "nodeType": "ArrayTypeName",
                      "src": "82:10:0",
                      "typeDescriptions": {
                        "typeIdentifier": "t_array$_t_bytes32_$6_storage_ptr",
                        "typeString": "bytes32[6]"
                      }
                    },
                    "id": 5,
                    "length": null,
                    "nodeType": "ArrayTypeName",
                    "src": "82:12:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_array$_t_bytes32_$6_storage_$dyn_storage_ptr",
                      "typeString": "bytes32[6][]"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 8,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 20,
                  "src": "96:4:0",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 7,
                    "name": "uint",
                    "nodeType": "ElementaryTypeName",
                    "src": "96:4:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 10,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 20,
                  "src": "102:4:0",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 9,
                    "name": "uint",
                    "nodeType": "ElementaryTypeName",
                    "src": "102:4:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 14,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 20,
                  "src": "108:10:0",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_bytes32_$4_calldata_ptr",
                    "typeString": "bytes32[4]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 11,
                      "name": "bytes32",
                      "nodeType": "ElementaryTypeName",
                      "src": "108:7:0",
                      "typeDescriptions": {
                        "typeIdentifier": "t_bytes32",
                        "typeString": "bytes32"
                      }
                    },
                    "id": 13,
                    "length": {
                      "argumentTypes": null,
                      "hexValue": "34",
                      "id": 12,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "116:1:0",
                      "subdenomination": null,
                      "typeDescriptions": {
                        "typeIdentifier": null,
                        "typeString": null
                      },
                      "value": "4"
                    },
                    "nodeType": "ArrayTypeName",
                    "src": "108:10:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_bytes32_$4_storage_ptr",
                      "typeString": "bytes32[4]"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "81:38:0"
            },
            "payable": false,
            "returnParameters": {
              "id": 18,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 17,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 20,
                  "src": "143:4:0",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bool",
                    "typeString": "bool"
                  },
                  "typeName": {
                    "id": 16,
                    "name": "bool",
                    "nodeType": "ElementaryTypeName",
                    "src": "143:4:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bool",
                      "typeString": "bool"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "142:6:0"
            },
            "scope": 21,
            "src": "55:96:0",
            "stateMutability": "pure",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 28,
        "src": "26:127:0"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": "@title Library to validate AZTEC zero-knowledge proofs\n@author Zachary Williamson, AZTEC\n@dev Don't include this as an internal library. This contract uses a static memory table to cache elliptic curve primitives and hashes.\nCalling this internally from another function will lead to memory mutation and undefined behaviour.\nThe intended use case is to call this externally via `staticcall`. External calls to OptimizedAZTEC can be treated as pure functions as this contract contains no storage and makes no external calls (other than to precompiles)\nCopyright Spilbury Holdings Ltd 2018. All rights reserved.\nWe will be releasing AZTEC as an open-source protocol that provides efficient transaction privacy for Ethereum.\nOur full vision of the protocol includes confidential cross-asset interactions via our family of AZTEC zero-knowledge proofs\nand the AZTEC token standard, stay tuned for updates!*",
        "fullyImplemented": true,
        "id": 27,
        "linearizedBaseContracts": [
          27
        ],
        "name": "AZTEC",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 25,
              "nodeType": "Block",
              "src": "1727:18854:0",
              "statements": [
                {
                  "externalReferences": [],
                  "id": 24,
                  "nodeType": "InlineAssembly",
                  "operations": "{\n    validateJoinSplit()\n    mstore(0x00, 404)\n    revert(0x00, 0x20)\n    function validateJoinSplit()\n    {\n        mstore(0x80, 7673901602397024137095011250362199966051872585513276903826533215767972925880)\n        mstore(0xa0, 8489654445897228341090914135473290831551238522473825886865492707826370766375)\n        let notes := add(0x04, calldataload(0x04))\n        let m := calldataload(0x24)\n        let n := calldataload(notes)\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let challenge := mod(calldataload(0x44), gen_order)\n        if gt(m, n)\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n        let kn := calldataload(sub(calldatasize(), 0xc0))\n        mstore(0x2a0, caller())\n        mstore(0x2c0, kn)\n        mstore(0x2e0, m)\n        kn := mulmod(sub(gen_order, kn), challenge, gen_order)\n        hashCommitments(notes, n)\n        let b := add(0x300, mul(n, 0x80))\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n            let k\n            let a := calldataload(add(noteIndex, 0x20))\n            let c := challenge\n            switch eq(add(i, 0x01), n)\n            case 1 {\n                k := kn\n                if eq(m, n)\n                {\n                    k := sub(gen_order, k)\n                }\n            }\n            case 0 {\n                k := calldataload(noteIndex)\n            }\n            validateCommitment(noteIndex, k, a)\n            switch gt(add(i, 0x01), m)\n            case 1 {\n                kn := addmod(kn, sub(gen_order, k), gen_order)\n                let x := mod(mload(0x00), gen_order)\n                k := mulmod(k, x, gen_order)\n                a := mulmod(a, x, gen_order)\n                c := mulmod(challenge, x, gen_order)\n                mstore(0x00, keccak256(0x00, 0x20))\n            }\n            case 0 {\n                kn := addmod(kn, k, gen_order)\n            }\n            calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n            calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n            mstore(0x120, sub(gen_order, c))\n            mstore(0x60, k)\n            mstore(0xc0, a)\n            let result := staticcall(gas(), 7, 0xe0, 0x60, 0x1a0, 0x40)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x120, 0x40))\n            result := and(result, staticcall(gas(), 7, 0x80, 0x60, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x120, 0x80, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x160, 0x80, b, 0x40))\n            if eq(i, m)\n            {\n                mstore(0x260, mload(0x20))\n                mstore(0x280, mload(0x40))\n                mstore(0x1e0, mload(0xe0))\n                mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n            }\n            if gt(i, m)\n            {\n                mstore(0x60, c)\n                result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x220, 0x40))\n                result := and(result, staticcall(gas(), 6, 0x220, 0x80, 0x260, 0x40))\n                result := and(result, staticcall(gas(), 6, 0x1a0, 0x80, 0x1e0, 0x40))\n            }\n            if iszero(result)\n            {\n                mstore(0x00, 400)\n                revert(0x00, 0x20)\n            }\n            b := add(b, 0x40)\n        }\n        if lt(m, n)\n        {\n            validatePairing(0x64)\n        }\n        let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n        if iszero(eq(expected, challenge))\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n        mstore(0x00, 0x01)\n        return(0x00, 0x20)\n    }\n    function validatePairing(t2)\n    {\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let t2_x_1 := calldataload(t2)\n        let t2_x_2 := calldataload(add(t2, 0x20))\n        let t2_y_1 := calldataload(add(t2, 0x40))\n        let t2_y_2 := calldataload(add(t2, 0x60))\n        if or(or(or(or(or(or(or(iszero(t2_x_1), iszero(t2_x_2)), iszero(t2_y_1)), iszero(t2_y_2)), eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)), eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)), eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)), eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        mstore(0x20, mload(0x1e0))\n        mstore(0x40, mload(0x200))\n        mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n        mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n        mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n        mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n        mstore(0xe0, mload(0x260))\n        mstore(0x100, mload(0x280))\n        mstore(0x140, t2_x_1)\n        mstore(0x120, t2_x_2)\n        mstore(0x180, t2_y_1)\n        mstore(0x160, t2_y_2)\n        let success := staticcall(gas(), 8, 0x20, 0x180, 0x20, 0x20)\n        if or(iszero(success), iszero(mload(0x20)))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function validateCommitment(note, k, a)\n    {\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let gammaX := calldataload(add(note, 0x40))\n        let gammaY := calldataload(add(note, 0x60))\n        let sigmaX := calldataload(add(note, 0x80))\n        let sigmaY := calldataload(add(note, 0xa0))\n        if iszero(and(and(and(eq(mod(a, gen_order), a), gt(a, 1)), and(eq(mod(k, gen_order), k), gt(k, 1))), and(eq(addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order), mulmod(sigmaY, sigmaY, field_order)), eq(addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order), mulmod(gammaY, gammaY, field_order)))))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function hashCommitments(notes, n)\n    {\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let index := add(add(notes, mul(i, 0xc0)), 0x60)\n            calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n        }\n        mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n    }\n}",
                  "src": "1737:18844:0"
                }
              ]
            },
            "documentation": "@dev AZTEC will take any transaction sent to it and attempt to validate a zero knowledge proof.\nIf the proof is not valid, the transaction will throw.\n@notice See AZTECInterface for how method calls should be constructed.\n'Cost' of raw elliptic curve primitives for a transaction: 260,700 gas + (124,500 * number of input notes) + (167,600 * number of output notes).\nFor a basic 'joinSplit' with 2 inputs and 2 outputs = 844,900 gas.\nAZTEC is written in YUL to enable manual memory management and for other efficiency savings.*",
            "id": 26,
            "implemented": true,
            "isConstructor": false,
            "isDeclaredConst": false,
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 22,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1707:2:0"
            },
            "payable": true,
            "returnParameters": {
              "id": 23,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1727:0:0"
            },
            "scope": 27,
            "src": "1699:18882:0",
            "stateMutability": "payable",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 28,
        "src": "1092:19491:0"
      }
    ],
    "src": "0:20583:0"
  },
  "legacyAST": {
    "absolutePath": "/Users/paulrberg/Documents/Work/AZTEC/Coding/AZTEC/contracts/AZTEC/AZTEC.sol",
    "exportedSymbols": {
      "AZTEC": [
        27
      ],
      "AZTECInterface": [
        21
      ]
    },
    "id": 28,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 1,
        "literals": [
          "solidity",
          "^",
          "0.4",
          ".24"
        ],
        "nodeType": "PragmaDirective",
        "src": "0:24:0"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "library",
        "documentation": null,
        "fullyImplemented": true,
        "id": 21,
        "linearizedBaseContracts": [
          21
        ],
        "name": "AZTECInterface",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 19,
              "nodeType": "Block",
              "src": "149:2:0",
              "statements": []
            },
            "documentation": null,
            "id": 20,
            "implemented": true,
            "isConstructor": false,
            "isDeclaredConst": true,
            "modifiers": [],
            "name": "validateJoinSplit",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 15,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 6,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 20,
                  "src": "82:12:0",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_array$_t_bytes32_$6_calldata_$dyn_calldata_ptr",
                    "typeString": "bytes32[6][]"
                  },
                  "typeName": {
                    "baseType": {
                      "baseType": {
                        "id": 2,
                        "name": "bytes32",
                        "nodeType": "ElementaryTypeName",
                        "src": "82:7:0",
                        "typeDescriptions": {
                          "typeIdentifier": "t_bytes32",
                          "typeString": "bytes32"
                        }
                      },
                      "id": 4,
                      "length": {
                        "argumentTypes": null,
                        "hexValue": "36",
                        "id": 3,
                        "isConstant": false,
                        "isLValue": false,
                        "isPure": false,
                        "kind": "number",
                        "lValueRequested": false,
                        "nodeType": "Literal",
                        "src": "90:1:0",
                        "subdenomination": null,
                        "typeDescriptions": {
                          "typeIdentifier": null,
                          "typeString": null
                        },
                        "value": "6"
                      },
                      "nodeType": "ArrayTypeName",
                      "src": "82:10:0",
                      "typeDescriptions": {
                        "typeIdentifier": "t_array$_t_bytes32_$6_storage_ptr",
                        "typeString": "bytes32[6]"
                      }
                    },
                    "id": 5,
                    "length": null,
                    "nodeType": "ArrayTypeName",
                    "src": "82:12:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_array$_t_bytes32_$6_storage_$dyn_storage_ptr",
                      "typeString": "bytes32[6][]"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 8,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 20,
                  "src": "96:4:0",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 7,
                    "name": "uint",
                    "nodeType": "ElementaryTypeName",
                    "src": "96:4:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 10,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 20,
                  "src": "102:4:0",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_uint256",
                    "typeString": "uint256"
                  },
                  "typeName": {
                    "id": 9,
                    "name": "uint",
                    "nodeType": "ElementaryTypeName",
                    "src": "102:4:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_uint256",
                      "typeString": "uint256"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 14,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 20,
                  "src": "108:10:0",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_bytes32_$4_calldata_ptr",
                    "typeString": "bytes32[4]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 11,
                      "name": "bytes32",
                      "nodeType": "ElementaryTypeName",
                      "src": "108:7:0",
                      "typeDescriptions": {
                        "typeIdentifier": "t_bytes32",
                        "typeString": "bytes32"
                      }
                    },
                    "id": 13,
                    "length": {
                      "argumentTypes": null,
                      "hexValue": "34",
                      "id": 12,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "116:1:0",
                      "subdenomination": null,
                      "typeDescriptions": {
                        "typeIdentifier": null,
                        "typeString": null
                      },
                      "value": "4"
                    },
                    "nodeType": "ArrayTypeName",
                    "src": "108:10:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_bytes32_$4_storage_ptr",
                      "typeString": "bytes32[4]"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "81:38:0"
            },
            "payable": false,
            "returnParameters": {
              "id": 18,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 17,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 20,
                  "src": "143:4:0",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bool",
                    "typeString": "bool"
                  },
                  "typeName": {
                    "id": 16,
                    "name": "bool",
                    "nodeType": "ElementaryTypeName",
                    "src": "143:4:0",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bool",
                      "typeString": "bool"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "142:6:0"
            },
            "scope": 21,
            "src": "55:96:0",
            "stateMutability": "pure",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 28,
        "src": "26:127:0"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": "@title Library to validate AZTEC zero-knowledge proofs\n@author Zachary Williamson, AZTEC\n@dev Don't include this as an internal library. This contract uses a static memory table to cache elliptic curve primitives and hashes.\nCalling this internally from another function will lead to memory mutation and undefined behaviour.\nThe intended use case is to call this externally via `staticcall`. External calls to OptimizedAZTEC can be treated as pure functions as this contract contains no storage and makes no external calls (other than to precompiles)\nCopyright Spilbury Holdings Ltd 2018. All rights reserved.\nWe will be releasing AZTEC as an open-source protocol that provides efficient transaction privacy for Ethereum.\nOur full vision of the protocol includes confidential cross-asset interactions via our family of AZTEC zero-knowledge proofs\nand the AZTEC token standard, stay tuned for updates!*",
        "fullyImplemented": true,
        "id": 27,
        "linearizedBaseContracts": [
          27
        ],
        "name": "AZTEC",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 25,
              "nodeType": "Block",
              "src": "1727:18854:0",
              "statements": [
                {
                  "externalReferences": [],
                  "id": 24,
                  "nodeType": "InlineAssembly",
                  "operations": "{\n    validateJoinSplit()\n    mstore(0x00, 404)\n    revert(0x00, 0x20)\n    function validateJoinSplit()\n    {\n        mstore(0x80, 7673901602397024137095011250362199966051872585513276903826533215767972925880)\n        mstore(0xa0, 8489654445897228341090914135473290831551238522473825886865492707826370766375)\n        let notes := add(0x04, calldataload(0x04))\n        let m := calldataload(0x24)\n        let n := calldataload(notes)\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let challenge := mod(calldataload(0x44), gen_order)\n        if gt(m, n)\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n        let kn := calldataload(sub(calldatasize(), 0xc0))\n        mstore(0x2a0, caller())\n        mstore(0x2c0, kn)\n        mstore(0x2e0, m)\n        kn := mulmod(sub(gen_order, kn), challenge, gen_order)\n        hashCommitments(notes, n)\n        let b := add(0x300, mul(n, 0x80))\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n            let k\n            let a := calldataload(add(noteIndex, 0x20))\n            let c := challenge\n            switch eq(add(i, 0x01), n)\n            case 1 {\n                k := kn\n                if eq(m, n)\n                {\n                    k := sub(gen_order, k)\n                }\n            }\n            case 0 {\n                k := calldataload(noteIndex)\n            }\n            validateCommitment(noteIndex, k, a)\n            switch gt(add(i, 0x01), m)\n            case 1 {\n                kn := addmod(kn, sub(gen_order, k), gen_order)\n                let x := mod(mload(0x00), gen_order)\n                k := mulmod(k, x, gen_order)\n                a := mulmod(a, x, gen_order)\n                c := mulmod(challenge, x, gen_order)\n                mstore(0x00, keccak256(0x00, 0x20))\n            }\n            case 0 {\n                kn := addmod(kn, k, gen_order)\n            }\n            calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n            calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n            mstore(0x120, sub(gen_order, c))\n            mstore(0x60, k)\n            mstore(0xc0, a)\n            let result := staticcall(gas(), 7, 0xe0, 0x60, 0x1a0, 0x40)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x120, 0x40))\n            result := and(result, staticcall(gas(), 7, 0x80, 0x60, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x120, 0x80, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x160, 0x80, b, 0x40))\n            if eq(i, m)\n            {\n                mstore(0x260, mload(0x20))\n                mstore(0x280, mload(0x40))\n                mstore(0x1e0, mload(0xe0))\n                mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n            }\n            if gt(i, m)\n            {\n                mstore(0x60, c)\n                result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x220, 0x40))\n                result := and(result, staticcall(gas(), 6, 0x220, 0x80, 0x260, 0x40))\n                result := and(result, staticcall(gas(), 6, 0x1a0, 0x80, 0x1e0, 0x40))\n            }\n            if iszero(result)\n            {\n                mstore(0x00, 400)\n                revert(0x00, 0x20)\n            }\n            b := add(b, 0x40)\n        }\n        if lt(m, n)\n        {\n            validatePairing(0x64)\n        }\n        let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n        if iszero(eq(expected, challenge))\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n        mstore(0x00, 0x01)\n        return(0x00, 0x20)\n    }\n    function validatePairing(t2)\n    {\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let t2_x_1 := calldataload(t2)\n        let t2_x_2 := calldataload(add(t2, 0x20))\n        let t2_y_1 := calldataload(add(t2, 0x40))\n        let t2_y_2 := calldataload(add(t2, 0x60))\n        if or(or(or(or(or(or(or(iszero(t2_x_1), iszero(t2_x_2)), iszero(t2_y_1)), iszero(t2_y_2)), eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)), eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)), eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)), eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        mstore(0x20, mload(0x1e0))\n        mstore(0x40, mload(0x200))\n        mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n        mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n        mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n        mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n        mstore(0xe0, mload(0x260))\n        mstore(0x100, mload(0x280))\n        mstore(0x140, t2_x_1)\n        mstore(0x120, t2_x_2)\n        mstore(0x180, t2_y_1)\n        mstore(0x160, t2_y_2)\n        let success := staticcall(gas(), 8, 0x20, 0x180, 0x20, 0x20)\n        if or(iszero(success), iszero(mload(0x20)))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function validateCommitment(note, k, a)\n    {\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let gammaX := calldataload(add(note, 0x40))\n        let gammaY := calldataload(add(note, 0x60))\n        let sigmaX := calldataload(add(note, 0x80))\n        let sigmaY := calldataload(add(note, 0xa0))\n        if iszero(and(and(and(eq(mod(a, gen_order), a), gt(a, 1)), and(eq(mod(k, gen_order), k), gt(k, 1))), and(eq(addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order), mulmod(sigmaY, sigmaY, field_order)), eq(addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order), mulmod(gammaY, gammaY, field_order)))))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function hashCommitments(notes, n)\n    {\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let index := add(add(notes, mul(i, 0xc0)), 0x60)\n            calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n        }\n        mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n    }\n}",
                  "src": "1737:18844:0"
                }
              ]
            },
            "documentation": "@dev AZTEC will take any transaction sent to it and attempt to validate a zero knowledge proof.\nIf the proof is not valid, the transaction will throw.\n@notice See AZTECInterface for how method calls should be constructed.\n'Cost' of raw elliptic curve primitives for a transaction: 260,700 gas + (124,500 * number of input notes) + (167,600 * number of output notes).\nFor a basic 'joinSplit' with 2 inputs and 2 outputs = 844,900 gas.\nAZTEC is written in YUL to enable manual memory management and for other efficiency savings.*",
            "id": 26,
            "implemented": true,
            "isConstructor": false,
            "isDeclaredConst": false,
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 22,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1707:2:0"
            },
            "payable": true,
            "returnParameters": {
              "id": 23,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1727:0:0"
            },
            "scope": 27,
            "src": "1699:18882:0",
            "stateMutability": "payable",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 28,
        "src": "1092:19491:0"
      }
    ],
    "src": "0:20583:0"
  },
  "compiler": {
    "name": "solc",
    "version": "0.4.24+commit.e67f0147.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.0.1",
  "updatedAt": "2019-01-15T14:33:05.865Z",
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  }
}